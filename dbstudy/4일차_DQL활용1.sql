-- HR 계정의 << EMPLOYEES 테이블 >>

-- SELECT 검색할 칼럼
-- FROM 테이블
-- [WHERE 조건식]
-- [GROUP BY 그룹화할 칼럼]
-- [ORDER BY 정렬 칼럼]

-- EMPLOYEES 테이블의 구조 확인
DESC EMPLOYEES;

-- 1. 전체 사원의 모든 칼럼을 조회한다.
SELECT *  -- * : 모든 칼럼
FROM EMPLOYEES;

SELECT EMPLOYEES.*  -- EMPLOYEES 테이블의 모든 칼럼
FROM EMPLOYEES;

SELECT E.*  -- E 테이블의 모든 칼럼
FROM EMPLOYEES E;  -- EMPLOYEES 테이블의 별명이 E 이다.


-- 2. EMPLOYEE_ID, FIRST_NAME, LAST_NAME 를 조회한다.
SELECT EMPLOYEE_ID, FIRST_NAME, LAST_NAME
FROM EMPLOYEES;

SELECT EMPLOYEES.EMPLOYEE_ID, EMPLOYEES.FIRST_NAME, EMPLOYEES.LAST_NAME
FROM EMPLOYEES;

SELECT EMP.EMPLOYEE_ID, EMP.FIRST_NAME, EMP.LAST_NAME
FROM EMPLOYEES EMP;  -- 테이블의 별명은 쿼리 작성자가 정한다.


-- 3. 연봉(SALARY)이 12000 이상인 사원들의 LAST_NAME, SALARY 를 조회한다.
SELECT LAST_NAME, SALARY
FROM EMPLOYEES
WHERE SALARY >= 12000;


-- 4. 사원번호(EMPLOYEE_ID)가 150 인 사원의 LAST_NAME, DEPARTMENT_ID 를 조회한다.
-- 정답
SELECT LAST_NAME, DEPARTMENT_ID
FROM EMPLOYEES
WHERE EMPLOYEE_ID = 150;


-- 1) 타입을 잘못 맞췄을 때 (EMPLOYEE_ID 가 숫자 타입인데 상수값을 문자로 작성한 경우)
SELECT LAST_NAME, DEPARTMENT_ID
FROM EMPLOYEES
WHERE EMPLOYEE_ID = '150';

-- 오라클에 의해서 다음과 같이 변환됩니다.
SELECT LAST_NAME, DEPARTMENT_ID
FROM EMPLOYEES
WHERE EMPLOYEE_ID = TO_NUMBER('150');  -- 큰 문제가 없다.


-- 2) 타입을 잘못 맞췄을 때 (EMPLOYEE_ID 가 문자 타입인데 상수값을 숫자로 작성한 경우)
SELECT LAST_NAME, DEPARTMENT_ID
FROM EMPLOYEES
WHERE EMPLOYEE_ID = 150;

-- 오라클에 의해서 다음과 같이 변환됩니다.
SELECT LAST_NAME, DEPARTMENT_ID
FROM EMPLOYEES
WHERE TO_NUMBER(EMPLOYEE_ID) = 150;  -- 성능이 떨어진다. ('왼쪽 칼럼 = 오른쪽 값' 조건에서 가급적 왼쪽 칼럼은 가공하지 않는다.)


-- 5. 커미션(COMMISSION_PCT)을 받는 모든 사원의 LAST_NAME, SALARY, COMMISSION_PCT 를 조회한다.
SELECT LAST_NAME, SALARY, COMMISSION_PCT
FROM EMPLOYEES
WHERE COMMISSION_PCT IS NOT NULL;


-- 6. 연봉(SALARY)이 5000 에서 12000 인 범위의 사원들의 FIRST_NAME, LAST_NAME, SALARY 를 조회한다.
SELECT FIRST_NAME, LAST_NAME, SALARY
FROM EMPLOYEES
WHERE SALARY >= 5000 AND SALARY <= 12000;

SELECT FIRST_NAME, LAST_NAME, SALARY
FROM EMPLOYEES
WHERE SALARY BETWEEN 5000 AND 12000;


-- 7. 연봉(SALARY)이 5000 에서 12000 사이의 범위가 아닌 사원들의 FIRST_NAME, LAST_NAME, SALARY 를 조회한다.
SELECT FIRST_NAME, LAST_NAME, SALARY
FROM EMPLOYEES
WHERE SALARY < 5000 OR SALARY > 12000;

SELECT FIRST_NAME, LAST_NAME, SALARY
FROM EMPLOYEES
WHERE SALARY NOT BETWEEN 5000 AND 12000;


-- 8. 직업(JOB_ID)이 SA_REP 이나 ST_CLERK 인 사원들의 전체 칼럼을 조회한다.
SELECT *
FROM EMPLOYEES
WHERE JOB_ID = 'SA_REP' OR JOB_ID = 'ST_CLERK';

SELECT *
FROM EMPLOYEES
WHERE JOB_ID IN('SA_REP', 'ST_CLERK');


-- 9. 연봉(SALARY)이 2500, 3500, 7000 이 아니며 직업(JOB_ID) 이 SA_REP 이나 ST_CLERK 인 사람들을 조회한다.
SELECT *
FROM EMPLOYEES
WHERE (SALARY != 2500 AND SALARY != 3500 AND SALARY <> 7000)
AND (JOB_ID = 'SA_REP' OR JOB_ID = 'ST_CLERK');

SELECT *
FROM EMPLOYEES
WHERE SALARY NOT IN(2500, 3500, 7000)
AND JOB_ID IN('SA_REP', 'ST_CLERK');


-- 10. 상사(MANAGER_ID)가 없는 사람들의 LAST_NAME, JOB_ID 를 조회한다.
SELECT LAST_NAME, JOB_ID
FROM EMPLOYEES
WHERE MANAGER_ID IS NULL;


-- 와일드카드 (만능문자)
-- 1. 모든 문자를 대체할 수 있는 만능문자
-- 2. 글자수에 상관 없이 사용가능한 %
-- 3. 한 글자를 대체할 수 있는 _ (밑줄)
-- 4. 와일드카드를 사용하는 경우 등호(=) 대신 LIKE 연산자를 사용

-- 마, 마차, 마라도, 마동석, 마요네즈 : 마로 시작하는 문자열 -> 마%
-- 공주, 백설공주, 평강공주, 우리나라공주 : 공주로 끝나는 문자열 -> %공주
-- 맨드라미, 아이언맨, 드라마맨또롱 : 맨을 포함하는 문자열 -> %맨%


-- 11. 성(LAST_NAME)에 u 가 포함되는 사원들의 EMPLOYEE_ID, LAST_NAME 을 조회한다.
SELECT EMPLOYEE_ID, LAST_NAME
FROM EMPLOYEES
WHERE LAST_NAME LIKE '%u%' OR LAST_NAME LIKE '%U%';

SELECT EMPLOYEE_ID, LAST_NAME
FROM EMPLOYEES
WHERE LAST_NAME LIKE IN('%u%', '%U%');  -- 처리가 안 됩니다.


-- 12. 전화번호(PHONE_NUMBER)가 650 으로 시작하는 사원들의 LAST_NAME, PHONE_NUMBER 를 조회한다.
SELECT LAST_NAME, PHONE_NUMBER
FROM EMPLOYEES
WHERE PHONE_NUMBER LIKE '650%';


-- 13. 성(LAST_NAME)의 네 번째 글자가 a 인 사원들의 LAST_NAME 을 조회한다.
SELECT LAST_NAME
FROM EMPLOYEES
WHERE LAST_NAME LIKE '___a%';


-- 14. 성(LAST_NAME) 에 a 또는 e 가 포함된 사원들의 LAST_NAME 을 조회한다.
SELECT LAST_NAME
FROM EMPLOYEES
WHERE LAST_NAME LIKE '%a%' OR LAST_NAME LIKE '%e%';


-- 15. 성(LAST_NAME) 에 a 와 e 가 모두 포함된 사원들의 LAST_NAME 을 조회한다.
SELECT LAST_NAME
FROM EMPLOYEES
WHERE LAST_NAME LIKE '%a%' AND LAST_NAME LIKE '%e%';


-- 16. 2008/02/20 ~ 2008/05/01 사이에 고용된(HIRE_DATE) 사원들의 LAST_NAME, EMPLOYEE_ID, HIRE_DATE 를 조회한다.
-- 날짜 표기 방법
-- 1) 98/12/31
-- 2) 1998/12/31
-- 3) 98-12-31
-- 4) 1998-12-31

SELECT LAST_NAME, EMPLOYEE_ID, HIRE_DATE
FROM EMPLOYEES
WHERE HIRE_DATE >= '08/02/20' AND HIRE_DATE <= '08/05/01';

SELECT LAST_NAME, EMPLOYEE_ID, HIRE_DATE
FROM EMPLOYEES
WHERE HIRE_DATE BETWEEN '08/02/20' AND '08/05/01';


-- 17. 2004년도에 고용된(HIRE_DATE) 모든 사원들의 LAST_NAME, EMPLOYEE_ID, HIRE_DATE 를 조회한다.
SELECT LAST_NAME, EMPLOYEE_ID, HIRE_DATE
FROM EMPLOYEES
WHERE HIRE_DATE BETWEEN '04/01/01' AND '04/12/31';

SELECT LAST_NAME, EMPLOYEE_ID, HIRE_DATE
FROM EMPLOYEES
WHERE HIRE_DATE LIKE '04%';


-- 18. 부서(DEPARTMENT_ID)를 조회하되 중복을 제거하여 조회한다.
SELECT DISTINCT DEPARTMENT_ID
FROM EMPLOYEES;


-- 19. 직업(JOB_ID)이 ST_CLERK 가 아닌 사원들의 부서번호(DEPARTMENT_ID)를 조회한다.
-- 단, 부서번호가 NULL인 값은 제외하고 부서번호의 중복을 제거한다.
SELECT DISTINCT DEPARTMENT_ID
FROM EMPLOYEES
WHERE JOB_ID != 'ST_CLERK'
AND DEPARTMENT_ID IS NOT NULL;


-- 20. 모든 사원들의 LAST_NAME, COMMISSION_PCT 를 조회하되 커미션(COMMISSION_PCT)이 없는 사원은 0으로 처리하여 조회한다.
SELECT LAST_NAME, NVL(COMMISSION_PCT, 0) 커미션
FROM EMPLOYEES;

SELECT LAST_NAME, NVL(COMMISSION_PCT, 0) AS 커미션
FROM EMPLOYEES;


-- 21. 커미션(COMMISSION_PCT)이 없는 사원들은 0으로 처리하고, 커미션이 있는 사원들은 기존 커미션보다 10% 인상된 상태로 조회한다.
SELECT NVL(COMMISSION_PCT, 0) * 1.1 AS 예상커미션
FROM EMPLOYEES;


-- 22. 커미션(COMMISSION_PCT)을 받는 사원들의 실제 커미션(COMMISSION = SALARY * COMMISSION_PCT)을 구하고,
-- EMPLOYEE_ID, FIRST_NAME, JOB_ID 와 함께 조회한다.

SELECT SALARY * NVL(COMMISSION_PCT, 0) AS COMMISSION, EMPLOYEE_ID, FIRST_NAME, JOB_ID
FROM EMPLOYEES
WHERE COMMISSION_PCT IS NOT NULL;

SELECT SALARY * COMMISSION_PCT AS COMMISSION, EMPLOYEE_ID, FIRST_NAME, JOB_ID
FROM EMPLOYEES
WHERE COMMISSION_PCT IS NOT NULL;



-- 23. 가장 오래 전에 입사(HIRE_DATE)한 직원부터 최근에 입사한 직원 순으로 LAST_NAME, HIRE_DATE 를 조회한다.
-- HIRE_DATE 기준 오름차순 정렬 : ASC (생략이 가능하다.)
SELECT LAST_NAME, HIRE_DATE
FROM EMPLOYEES
ORDER BY HIRE_DATE;
-- ORDER BY HIRE_DATE ASC;


-- 24. 부서번호(DEPARTMENT_ID)가 20, 50 인 부서에서 근무하는 모든 사원들의 부서번호의 오름차순으로 조회하되,
-- 같은 부서번호 내에서는 LAST_NAME 의 알파벳순으로 조회한다.
-- 2개 정렬 : ORDER BY 칼럼1, 칼럼2
-- 정렬은 우선 순위가 있다.
-- 칼럼1 로 정렬한 뒤 같은 값을 가지는 데이터들만 칼럼2로 다시 정렬한다.
-- ORDER BY 절은 항상 마지막에 배치한다.
SELECT *
FROM EMPLOYEES
WHERE DEPARTMENT_ID IN (20, 50)
ORDER BY DEPARTMENT_ID, LAST_NAME;


-- 25. 커미션(COMMISSION_PCT)을 받는 모든 사원들의 LAST_NAME, SALARY, COMMISSION_PCT 을 조회한다.
-- 연봉이 높은 사원을 먼저 조회하고 같은 연봉의 사원들은 커미션이 높은 사원을 먼저 조회한다.
-- 연봉이 높은 순 : 내림차순 정렬
-- 커미션이 높은 순 : 내림차순 정렬

SELECT LAST_NAME, SALARY, COMMISSION_PCT
FROM EMPLOYEES
WHERE COMMISSION_PCT IS NOT NULL
ORDER BY SALARY DESC, COMMISSION_PCT DESC;
