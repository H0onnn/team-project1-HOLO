-- 26. 연봉(SALARY) 총액과 연봉(SALARY) 평균을 조회한다.
SELECT TO_CHAR(SUM(SALARY), '999,999') AS 연봉총액, TO_CHAR(AVG(SALARY), '9,999.99') AS 평균연봉
FROM EMPLOYEES;


-- 27. 최대연봉(SALARY)과 최소연봉의 차이를 조회한다.
SELECT MAX(SALARY) - MIN(SALARY) AS SALARY_GAP
FROM EMPLOYEES;


-- 28. 직업(JOB_ID) 이 ST_CLERK 인 사원들의 전체 수를 조회한다.
SELECT COUNT(*) AS 사원수
FROM EMPLOYEES
WHERE JOB_ID = 'ST_CLERK';


-- 29. 매니저(상사)(MANAGER_ID)가 있는 사원들의 전체 수를 조회한다.
SELECT COUNT(*)
FROM EMPLOYEES
WHERE MANAGER_ID IS NOT NULL;

SELECT COUNT(MANAGER_ID)
FROM EMPLOYEES;


-- 30. 회사 내에 사원들이 근무하는 부서(DEPARTMENT_ID)가 몇 개 인지 조회한다.
SELECT COUNT(DISTINCT DEPARTMENT_ID)
FROM EMPLOYEES;


-- 그룹화 연습
-- DEPARTMENTS 테이블 이용


-- 31. 같은 지역(LOCATION_ID) 끼리 모아서 조회한다.
SELECT LOCATION_ID
FROM DEPARTMENTS
GROUP BY LOCATION_ID;

SELECT DISTINCT LOCATION_ID
FROM DEPARTMENTS;


-- 32. 같은 지역(LOCATION_ID) 끼리 모아서 각 지역(LOCATION_ID) 마다 총 몇 개의 부서가 있는지 개수를 함께 조회한다.

SELECT LOCATION_ID, COUNT(*) AS 부서개수
FROM DEPARTMENTS
GROUP BY LOCATION_ID;


-- 33. 같은 지역(LOCATION_ID) 끼리 모아서 해당 지역(LOCATION_ID) 에 어떤 부서(DEPARTMENT_NAME) 가 있는지 조회한다.

-- GROUP BY 를 사용하는 경우
-- SELECT 절의 칼럼(DEPARTMENT_NAME)은 반드시 GROUP BY 절에도 존재해야 한다.

SELECT LOCATION_ID, DEPARTMENT_NAME
FROM DEPARTMENTS
GROUP BY LOCATION_ID;


-- 그룹화 연습
-- EMPLOYEES 테이블 이용

-- 34. 각 부서(DEPARTMENT_ID)별로 그룹화하여 DEPARTMENT_ID 와 부서별 사원의 수를 출력한다.
SELECT DEPARTMENT_ID, COUNT(*) AS 부서별사원수
FROM EMPLOYEES
GROUP BY DEPARTMENT_ID;


-- 35. 부서(DEPARTMENT_ID)별로 집계하여 DEPARTMENT_ID 와 급여(SALARY)평균을 DEPARTMENT_ID 순으로 오름차순 정렬해서 출력한다.
SELECT DEPARTMENT_ID, TO_CHAR(AVG(SALARY), '99,999') AS 급여평균  -- DEPARTMENT_ID 와 급여(SALARY)평균을
FROM EMPLOYEES
GROUP BY DEPARTMENT_ID  -- 부서(DEPARTMENT_ID)별로 집계하여
ORDER BY DEPARTMENT_ID;  -- DEPARTMENT_ID 순으로 오름차순 정렬해서 출력한다.


-- 36. 동일한 직업(JOB_ID)을 가진 사원들의 JOB_ID 와 인원수와 급여평균을 급여평균의 오름차순 정렬하여 출력한다.
SELECT JOB_ID, COUNT(*) AS 인원수, TRUNC(AVG(SALARY)) AS 급여평균
FROM EMPLOYEES
GROUP BY JOB_ID
ORDER BY AVG(SALARY);


-- 37. 직업(JOB_ID)이 SH_CLERK 인 직원들의 인원수와 최대급여 및 최소급여를 출력한다.
SELECT COUNT(*), MAX(SALARY), MIN(SALARY)
FROM EMPLOYEES
WHERE JOB_ID = 'SH_CLERK';

-- GROUP BY 후에 HAVING 조건을 주는 것은 WHERE 절의 조건으로 처리하는 것보다 성능이 떨어진다.
-- 아래와 같은 쿼리는 안 좋다.
SELECT COUNT(*), MAX(SALARY), MIN(SALARY)
FROM EMPLOYEES
GROUP BY JOB_ID
HAVING JOB_ID = 'SH_CLERK';


-- 38. 근무중인 사원수가 5명 이상인 부서의 DEPARTMENT_ID 와 해당 부서의 사원수를 DEPARTMENT_ID 의 오름차순으로 정렬하여 출력한다.
SELECT DEPARTMENT_ID, COUNT(*) AS 부서별사원수
FROM EMPLOYEES
GROUP BY DEPARTMENT_ID
HAVING COUNT(*) >= 5;  -- GROUP 후에 처리해야 하는 조건은 HAVING 절로 처리한다.


-- 39. 평균급여가 10000 이상인 부서의 DEPARTMENT_ID 와 급여평균을 출력한다.
SELECT DEPARTMENT_ID, TO_CHAR(AVG(SALARY), '99,999') AS 급여평균
FROM EMPLOYEES
GROUP BY DEPARTMENT_ID
HAVING AVG(SALARY) >= 10000;


-- 40. 부서(DEPARTMENT_ID)마다 같은 직업(JOB_ID)을 가진 사원수를 DEPARTMENT_ID 순으로 정렬하여 출력한다.
-- 단, DEPARTMENT_ID 가 없는 사원은 출력하지 않는다.

SELECT DEPARTMENT_ID, JOB_ID, COUNT(*) AS 직업별사원수
FROM EMPLOYEES
WHERE DEPARTMENT_ID IS NOT NULL
GROUP BY DEPARTMENT_ID, JOB_ID
ORDER BY DEPARTMENT_ID;


