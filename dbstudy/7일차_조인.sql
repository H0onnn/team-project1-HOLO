-- 1. 부서의 위치(LOCATION_ID)가 1700 인 사원들의 EMPLOYEE_ID, LAST_NAME, DEPARTMENT_ID, SALARY 를 조회한다.
-- 사용할 테이블 (DEPARTMENTS, EMPLOYEES)
SELECT E.EMPLOYEE_ID, E.LAST_NAME, E.DEPARTMENT_ID, E.SALARY
FROM DEPARTMENTS D, EMPLOYEES E
WHERE D.DEPARTMENT_ID = E.DEPARTMENT_ID  -- 조인 조건
AND D.LOCATION_ID = 1700;  -- 일반 조건


-- 2. 부서명(DEPARTMENT_NAME)이 'Executive' 인 부서에 근무하는 모든 사원들의 DEPARTMENT_ID, LAST_NAME, JOB_ID 를 조회한다.
-- 사용할 테이블 (DEPARTMENTS, EMPLOYEES)
SELECT E.DEPARTMENT_ID, E.LAST_NAME, E.JOB_ID
FROM DEPARTMENTS D INNER JOIN EMPLOYEES E
ON D.DEPARTMENT_ID = E.DEPARTMENT_ID  -- 조인 조건
WHERE D.DEPARTMENT_NAME = 'Executive';


-- 3. 기존의 직업(JOB_ID)을 여전히 가지고 있는 사원들의 EMPLOYEE_ID, JOB_ID 를 조회한다.
-- 사용할 테이블 (EMPLOYEES, JOB_HISTORY)
SELECT E.EMPLOYEE_ID, E.JOB_ID
FROM EMPLOYEES E INNER JOIN JOB_HISTORY J
ON E.EMPLOYEE_ID = J.EMPLOYEE_ID  -- 조인 조건1
AND E.JOB_ID = J.JOB_ID;  -- 조인 조건2


-- 4. 각 부서별 사원수와 평균연봉(SALARY)을 DEPARTMENT_NAME, LOCATION_ID 와 함께 조회한다.
-- 평균연봉은 소수점 2 자리까지 반올림하여 표현하고, 각 부서별 사원수의 오름차순으로 조회한다.
-- 사용할 테이블 (DEPARTMENTS, EMPLOYEES)
SELECT D.DEPARTMENT_NAME, D.LOCATION_ID, COUNT(*) AS 부서별사원수, ROUND(AVG(E.SALARY), 2) AS 평균연봉
FROM DEPARTMENTS D INNER JOIN EMPLOYEES E
ON D.DEPARTMENT_ID = E.DEPARTMENT_ID  -- 조인 조건
GROUP BY D.DEPARTMENT_NAME, D.LOCATION_ID  -- GROUP BY 절을 사용하려면 SELECT 절의 모든 칼럼을 GROUP BY 절에 둬야 한다.
ORDER BY COUNT(*);


-- 5. 도시이름(CITY)이 T 로 시작하는 지역에 근무하는 사원들의 EMPLOYEE_ID, LAST_NAME, DEPARTMENT_ID, CITY 를 조회한다.
-- 사용할 테이블 (EMPLOYEES, DEPARTMENTS, LOCATIONS)
-- EMPLOYEES 테이블 : DEPARTMENT_ID (부서번호)
-- DEPARTMENTS 테이블 : DEPARTMENT_ID (부서번호), LOCATION_ID (지역번호)
-- LOCATIONS 테이블 : LOCATION_ID (지역번호), CITY (도시)
-- 1) 콤마 구분법
SELECT E.EMPLOYEE_ID, E.LAST_NAME, E.DEPARTMENT_ID, L.CITY
FROM EMPLOYEES E, DEPARTMENTS D, LOCATIONS L
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID  -- 조인 조건1
AND D.LOCATION_ID = L.LOCATION_ID  -- 조인 조건2
AND L.CITY LIKE 'T%';  -- 일반 조건


-- 2) JOIN 문법
SELECT E.EMPLOYEE_ID, E.LAST_NAME, E.DEPARTMENT_ID, L.CITY
FROM EMPLOYEES E INNER JOIN DEPARTMENTS D
ON E.DEPARTMENT_ID = D.DEPARTMENT_ID INNER JOIN LOCATIONS L
ON D.LOCATION_ID = L.LOCATION_ID
WHERE L.CITY LIKE 'T%';


-- 6. 자신의 담당 매니저(MANAGER_ID)의 고용일(HIRE_DATE)보다 빨리 입사한 사원을 찾아서 LAST_NAME, HIRE_DATE, MANAGER_ID 를 조회한다. 
-- 사용할 테이블 (EMPLOYEES)
-- 사원이름(LAST_NAME), 사원고용일(HIRE_DATE), 상사이름(LAST_NAME), 상사고용일(HIRE_DATE)
-- 사원테이블 : EMPLOYEES E
-- 상사테이블 : EMPLOYEES M
-- 조인조건 : 사원테이블의 상사번호(MANAGER_ID) = 상사테이블의 사원번호(EMPLOYEE_ID)
SELECT E.LAST_NAME AS 사원이름, E.HIRE_DATE AS 사원고용일, M.LAST_NAME AS 상사이름, M.HIRE_DATE AS 상사고용일
FROM EMPLOYEES E, EMPLOYEES M
WHERE E.MANAGER_ID = M.EMPLOYEE_ID  -- 조인조건
AND E.HIRE_DATE < M.HIRE_DATE;  -- 일반조건


-- 7. 같은 소속부서(DEPARTMENT_ID)에서 나보다 늦게 입사(HIRE_DATE)하였으나 나보다 높은 연봉(SALARY)을 받는 사원이 존재하는 사원들의
-- DEPARTMENT_ID, FULL_NAME(FIRST_NAME 과 LAST_NAME 사이에 공백을 포함하여 연결), SALARY, HIRE_DATE 를 FULL_NAME 순으로 정렬하여 조회한다.
-- 사용할 테이블 (EMPLOYEES)

-- 거의 답이지만 답은 아닙니다.
-- 조건을 만족하는 사원은 사원테이블에서도 검색되고, 상사테이블에서도 검색되기 때문에 중복되는 데이터가 많습니다.
SELECT E.DEPARTMENT_ID, E.FIRST_NAME || ' ' || E.LAST_NAME AS FULL_NAME, E.SALARY, E.HIRE_DATE
FROM EMPLOYEES E, EMPLOYEES M
WHERE E.DEPARTMENT_ID = M.DEPARTMENT_ID  -- 조인조건
AND E.HIRE_DATE < M.HIRE_DATE  -- 일반조건 (먼저 입사했고,)
AND E.SALARY < M.SALARY  -- 일반조건 (연봉도 적다.)
ORDER BY FULL_NAME;

-- 양 테이블에서 공통으로 검색되는 데이터의 중복을 제거(DISTINCT)해 줍니다.
SELECT DISTINCT E.DEPARTMENT_ID, E.FIRST_NAME || ' ' || E.LAST_NAME AS FULL_NAME, E.SALARY, E.HIRE_DATE
FROM EMPLOYEES E, EMPLOYEES M
WHERE E.DEPARTMENT_ID = M.DEPARTMENT_ID  -- 조인조건
AND E.HIRE_DATE < M.HIRE_DATE  -- 일반조건 (먼저 입사했고,)
AND E.SALARY < M.SALARY  -- 일반조건 (연봉도 적다.)
ORDER BY FULL_NAME;


-- 8. 같은 소속부서(DEPARTMENT_ID)의 다른 사원보다 늦게 입사(HIRE_DATE)하였으나 현재 더 높은 연봉(SALARY)을 받는 사원들의
-- DEPARTMENT_ID, FULL_NAME(FIRST_NAME 과 LAST_NAME 사이에 공백을 포함하여 연결), SALARY, HIRE_DATE 를 FULL_NAME 순으로 정렬하여 조회한다.
-- 사용할 테이블 (EMPLOYEES)
SELECT DISTINCT M.DEPARTMENT_ID, M.FIRST_NAME || ' ' || M.LAST_NAME AS FULL_NAME, M.SALARY, M.HIRE_DATE
FROM EMPLOYEES E, EMPLOYEES M
WHERE E.DEPARTMENT_ID = M.DEPARTMENT_ID  -- 조인조건
AND E.HIRE_DATE < M.HIRE_DATE  -- 일반조건 (먼저 입사했고,)
AND E.SALARY < M.SALARY  -- 일반조건 (연봉도 적다.)
ORDER BY FULL_NAME;